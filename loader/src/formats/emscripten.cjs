const DEFAULT_GAS_LIMIT = 9_000_000_000_000_000

/* eslint-disable */
const Module = (() => {
  let _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename
  return (
    function (binaryOrInstantiate, { computeLimit, memoryLimit, extensions, format }) {
      var Module = Module || {}
      if (typeof binaryOrInstantiate === 'function') Module.instantiateWasm = binaryOrInstantiate
      else Module.wasmBinary = binaryOrInstantiate

      /**
       * Expose gas on the module
       * 
       * This is how we track the amount of ops this WASM module has used,
       * and also how we refill the gas on each invocation of the WASM.
       */
      Module.gas = {
        limit: computeLimit || DEFAULT_GAS_LIMIT,
        used: 0,
        use: (amount) => {
          Module.gas.used += amount
        },
        refill: (amount) => {
          if (!amount) Module.gas.used = 0
          else Module.gas.used = Math.max(Module.gas.used - amount, 0)
        },
        isEmpty: () => Module.gas.used > Module.gas.limit
      }

      /**
       * See this issue with emscripten https://github.com/emscripten-core/emscripten/issues/12740
       *
       * We need to manually cleanup any listeners that are setup as part of the WASM module,
       * so that they can be deregistered later and the associated WASM memory can be garbage collected
       *
       * This is custom code we've added to the emscripten module code.
       */
      const _listeners_ = []
      Module.cleanupListeners = function () {
        /**
         * Deregister any listeners that did not exist before this
         * WASM module was bootstrapped
         */
        _listeners_.forEach(([name, l]) => process.removeListener(name, l))
      }
      function uncaughtException(ex) { if (!(ex instanceof ExitStatus)) { throw ex } }
      function unhandledRejection(reason) { throw reason }
      _listeners_.push(['uncaughtException', uncaughtException], ['unhandledRejection', unhandledRejection])

      var Module = typeof Module !== 'undefined' ? Module : {}; let readyPromiseResolve, readyPromiseReject; Module.ready = new Promise(function (resolve, reject) { readyPromiseResolve = resolve; readyPromiseReject = reject }); Module.locateFile = url => { return url }; let moduleOverrides = Object.assign({}, Module); let arguments_ = []; let thisProgram = './this.program'; let quit_ = (status, toThrow) => { throw toThrow }; const ENVIRONMENT_IS_WEB = typeof window === 'object'; const ENVIRONMENT_IS_WORKER = typeof importScripts === 'function'; const ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string'; let scriptDirectory = ''; function locateFile(path) { if (Module.locateFile) { return Module.locateFile(path, scriptDirectory) } return scriptDirectory + path } let read_, readAsync, readBinary, setWindowTitle; function logExceptionOnExit(e) { if (e instanceof ExitStatus) return; const toLog = e; err('exiting due to exception: ' + toLog) } let fs; let nodePath; let requireNodeFS; if (ENVIRONMENT_IS_NODE) { if (ENVIRONMENT_IS_WORKER) { scriptDirectory = require('path').dirname(scriptDirectory) + '/' } else { scriptDirectory = __dirname + '/' } requireNodeFS = () => { if (!nodePath) { fs = require('fs'); nodePath = require('path') } }; read_ = function shell_read(filename, binary) { requireNodeFS(); filename = nodePath.normalize(filename); return fs.readFileSync(filename, binary ? undefined : 'utf8') }; readBinary = filename => { let ret = read_(filename, true); if (!ret.buffer) { ret = new Uint8Array(ret) } return ret }; readAsync = (filename, onload, onerror) => { requireNodeFS(); filename = nodePath.normalize(filename); fs.readFile(filename, function (err, data) { if (err) onerror(err); else onload(data.buffer) }) }; if (process.argv.length > 1) { thisProgram = process.argv[1].replace(/\\/g, '/') } arguments_ = process.argv.slice(2); process.on('uncaughtException', uncaughtException); process.on('unhandledRejection', unhandledRejection); quit_ = (status, toThrow) => { if (keepRuntimeAlive()) { process.exitCode = status; throw toThrow } logExceptionOnExit(toThrow); process.exit(status) }; Module.inspect = function () { return '[Emscripten Module object]' } } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { if (ENVIRONMENT_IS_WORKER) { scriptDirectory = self.location.href } else if (typeof document !== 'undefined' && document.currentScript) { scriptDirectory = document.currentScript.src } if (_scriptDir) { scriptDirectory = _scriptDir } if (scriptDirectory.indexOf('blob:') !== 0) { scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1) } else { scriptDirectory = '' } { read_ = url => { const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.send(null); return xhr.responseText }; if (ENVIRONMENT_IS_WORKER) { readBinary = url => { const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.responseType = 'arraybuffer'; xhr.send(null); return new Uint8Array(xhr.response) } } readAsync = (url, onload, onerror) => { const xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.responseType = 'arraybuffer'; xhr.onload = () => { if (xhr.status == 200 || xhr.status == 0 && xhr.response) { onload(xhr.response); return } onerror() }; xhr.onerror = onerror; xhr.send(null) } } setWindowTitle = title => document.title = title } else { } const out = Module.print || console.log.bind(console); var err = Module.printErr || console.warn.bind(console); Object.assign(Module, moduleOverrides); moduleOverrides = null; if (Module.arguments) arguments_ = Module.arguments; if (Module.thisProgram) thisProgram = Module.thisProgram; if (Module.quit) quit_ = Module.quit; let tempRet0 = 0; const setTempRet0 = value => { tempRet0 = value }; const getTempRet0 = () => tempRet0; let wasmBinary; if (Module.wasmBinary) wasmBinary = Module.wasmBinary; const noExitRuntime = Module.noExitRuntime || true; if (typeof WebAssembly !== 'object') { abort('no native wasm support detected') } let wasmMemory; let ABORT = false; let EXITSTATUS; function getCFunc(ident) { const func = Module['_' + ident]; return func } function ccall(ident, returnType, argTypes, args, opts) { const toC = { string: function (str) { let ret = 0; if (str !== null && str !== undefined && str !== 0) { const len = (str.length << 2) + 1; ret = stackAlloc(len); stringToUTF8(str, ret, len) } return ret }, array: function (arr) { const ret = stackAlloc(arr.length); writeArrayToMemory(arr, ret); return ret } }; function convertReturnValue(ret) { if (returnType === 'string') { return UTF8ToString(ret) } if (returnType === 'boolean') return Boolean(ret); return ret } const func = getCFunc(ident); const cArgs = []; let stack = 0; if (args) { for (let i = 0; i < args.length; i++) { const converter = toC[argTypes[i]]; if (converter) { if (stack === 0) stack = stackSave(); cArgs[i] = converter(args[i]) } else { cArgs[i] = args[i] } } } let ret = func.apply(null, cArgs); function onDone(ret) { if (stack !== 0) stackRestore(stack); return convertReturnValue(ret) } ret = onDone(ret); return ret } function cwrap(ident, returnType, argTypes, opts) { argTypes = argTypes || []; const numericArgs = argTypes.every(function (type) { return type === 'number' }); const numericRet = returnType !== 'string'; if (numericRet && numericArgs && !opts) { return getCFunc(ident) } return function () { return ccall(ident, returnType, argTypes, arguments, opts) } } const UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined; function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) { const endIdx = idx + maxBytesToRead; let endPtr = idx; while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr; if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) { return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr)) } else { var str = ''; while (idx < endPtr) { let u0 = heapOrArray[idx++]; if (!(u0 & 128)) { str += String.fromCharCode(u0); continue } const u1 = heapOrArray[idx++] & 63; if ((u0 & 224) == 192) { str += String.fromCharCode((u0 & 31) << 6 | u1); continue } const u2 = heapOrArray[idx++] & 63; if ((u0 & 240) == 224) { u0 = (u0 & 15) << 12 | u1 << 6 | u2 } else { u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63 } if (u0 < 65536) { str += String.fromCharCode(u0) } else { const ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } } } return str } function UTF8ToString(ptr, maxBytesToRead) { return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '' } function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) { if (!(maxBytesToWrite > 0)) return 0; const startIdx = outIdx; const endIdx = outIdx + maxBytesToWrite - 1; for (let i = 0; i < str.length; ++i) { let u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) { const u1 = str.charCodeAt(++i); u = 65536 + ((u & 1023) << 10) | u1 & 1023 } if (u <= 127) { if (outIdx >= endIdx) break; heap[outIdx++] = u } else if (u <= 2047) { if (outIdx + 1 >= endIdx) break; heap[outIdx++] = 192 | u >> 6; heap[outIdx++] = 128 | u & 63 } else if (u <= 65535) { if (outIdx + 2 >= endIdx) break; heap[outIdx++] = 224 | u >> 12; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } else { if (outIdx + 3 >= endIdx) break; heap[outIdx++] = 240 | u >> 18; heap[outIdx++] = 128 | u >> 12 & 63; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } } heap[outIdx] = 0; return outIdx - startIdx } function stringToUTF8(str, outPtr, maxBytesToWrite) { return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite) } function lengthBytesUTF8(str) { let len = 0; for (let i = 0; i < str.length; ++i) { let u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023; if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4 } return len } function allocateUTF8(str) { const size = lengthBytesUTF8(str) + 1; const ret = _malloc(size); if (ret) stringToUTF8Array(str, HEAP8, ret, size); return ret } function writeArrayToMemory(array, buffer) { HEAP8.set(array, buffer) } function writeAsciiToMemory(str, buffer, dontAddNull) { for (let i = 0; i < str.length; ++i) { HEAP8[buffer++ >> 0] = str.charCodeAt(i) } if (!dontAddNull) HEAP8[buffer >> 0] = 0 } let buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64; function updateGlobalBufferAndViews(buf) { buffer = buf; Module.HEAP8 = HEAP8 = new Int8Array(buf); Module.HEAP16 = HEAP16 = new Int16Array(buf); Module.HEAP32 = HEAP32 = new Int32Array(buf); Module.HEAPU8 = HEAPU8 = new Uint8Array(buf); Module.HEAPU16 = HEAPU16 = new Uint16Array(buf); Module.HEAPU32 = HEAPU32 = new Uint32Array(buf); Module.HEAPF32 = HEAPF32 = new Float32Array(buf); Module.HEAPF64 = HEAPF64 = new Float64Array(buf) } const INITIAL_MEMORY = Module.INITIAL_MEMORY || 6291456; let wasmTable; const __ATPRERUN__ = []; const __ATINIT__ = []; const __ATMAIN__ = []; const __ATPOSTRUN__ = []; let runtimeInitialized = false; function keepRuntimeAlive() { return noExitRuntime } function preRun() { if (Module.preRun) { if (typeof Module.preRun === 'function') Module.preRun = [Module.preRun]; while (Module.preRun.length) { addOnPreRun(Module.preRun.shift()) } } callRuntimeCallbacks(__ATPRERUN__) } function initRuntime() { runtimeInitialized = true; callRuntimeCallbacks(__ATINIT__) } function preMain() { callRuntimeCallbacks(__ATMAIN__) } function postRun() { if (Module.postRun) { if (typeof Module.postRun === 'function') Module.postRun = [Module.postRun]; while (Module.postRun.length) { addOnPostRun(Module.postRun.shift()) } } callRuntimeCallbacks(__ATPOSTRUN__) } function addOnPreRun(cb) { __ATPRERUN__.unshift(cb) } function addOnInit(cb) { __ATINIT__.unshift(cb) } function addOnPostRun(cb) { __ATPOSTRUN__.unshift(cb) } let runDependencies = 0; let runDependencyWatcher = null; let dependenciesFulfilled = null; function addRunDependency(id) { runDependencies++; if (Module.monitorRunDependencies) { Module.monitorRunDependencies(runDependencies) } } function removeRunDependency(id) { runDependencies--; if (Module.monitorRunDependencies) { Module.monitorRunDependencies(runDependencies) } if (runDependencies == 0) { if (runDependencyWatcher !== null) { clearInterval(runDependencyWatcher); runDependencyWatcher = null } if (dependenciesFulfilled) { const callback = dependenciesFulfilled; dependenciesFulfilled = null; callback() } } } function abort(what) { { if (Module.onAbort) { Module.onAbort(what) } } what = 'Aborted(' + what + ')'; err(what); ABORT = true; EXITSTATUS = 1; what += '. Build with -sASSERTIONS for more info.'; const e = new WebAssembly.RuntimeError(what); readyPromiseReject(e); throw e } const dataURIPrefix = 'data:application/octet-stream;base64,'; function isDataURI(filename) { return filename.startsWith(dataURIPrefix) } function isFileURI(filename) { return filename.startsWith('file://') } let wasmBinaryFile; wasmBinaryFile = 'process.wasm'; if (!isDataURI(wasmBinaryFile)) { wasmBinaryFile = locateFile(wasmBinaryFile) } function getBinary(file) { try { if (file == wasmBinaryFile && wasmBinary) { return new Uint8Array(wasmBinary) } if (readBinary) { return readBinary(file) } else { throw 'both async and sync fetching of the wasm failed' } } catch (err) { abort(err) } } function getBinaryPromise() { if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) { if (typeof fetch === 'function' && !isFileURI(wasmBinaryFile)) { return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) { if (!response.ok) { throw "failed to load wasm binary file at '" + wasmBinaryFile + "'" } return response.arrayBuffer() }).catch(function () { return getBinary(wasmBinaryFile) }) } else { if (readAsync) { return new Promise(function (resolve, reject) { readAsync(wasmBinaryFile, function (response) { resolve(new Uint8Array(response)) }, reject) }) } } } return Promise.resolve().then(function () { return getBinary(wasmBinaryFile) }) } function createWasm() { const info = { a: asmLibraryArg, metering: { usegas: function (gas) { Module.gas.use(gas); if (Module.gas.isEmpty()) throw Error('out of gas!') } } }; function receiveInstance(instance, module) { const exports = instance.exports; Module.asm = exports; wasmMemory = Module.asm.E; updateGlobalBufferAndViews(wasmMemory.buffer); wasmTable = Module.asm.I; addOnInit(Module.asm.F); removeRunDependency('wasm-instantiate') } addRunDependency('wasm-instantiate'); function receiveInstantiationResult(result) { receiveInstance(result.instance) } function instantiateArrayBuffer(receiver) { return getBinaryPromise().then(function (binary) { return WebAssembly.instantiate(binary, info) }).then(function (instance) { return instance }).then(receiver, function (reason) { err('failed to asynchronously prepare wasm: ' + reason); abort(reason) }) } function instantiateAsync() { if (!wasmBinary && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch === 'function') { return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) { const result = WebAssembly.instantiateStreaming(response, info); return result.then(receiveInstantiationResult, function (reason) { err('wasm streaming compile failed: ' + reason); err('falling back to ArrayBuffer instantiation'); return instantiateArrayBuffer(receiveInstantiationResult) }) }) } else { return instantiateArrayBuffer(receiveInstantiationResult) } } if (Module.instantiateWasm) { try { const exports = Module.instantiateWasm(info, receiveInstance); return exports } catch (e) { err('Module.instantiateWasm callback failed with error: ' + e); return false } } instantiateAsync().catch(readyPromiseReject); return {} } function callRuntimeCallbacks(callbacks) { while (callbacks.length > 0) { const callback = callbacks.shift(); if (typeof callback === 'function') { callback(Module); continue } const func = callback.func; if (typeof func === 'number') { if (callback.arg === undefined) { getWasmTableEntry(func)() } else { getWasmTableEntry(func)(callback.arg) } } else { func(callback.arg === undefined ? null : callback.arg) } } } function getWasmTableEntry(funcPtr) { return wasmTable.get(funcPtr) } function handleException(e) { if (e instanceof ExitStatus || e == 'unwind') { return EXITSTATUS } quit_(1, e) } var SYSCALLS = { varargs: undefined, get: function () { SYSCALLS.varargs += 4; const ret = HEAP32[SYSCALLS.varargs - 4 >> 2]; return ret }, getStr: function (ptr) { const ret = UTF8ToString(ptr); return ret } }; function ___syscall_dup3(fd, suggestFD, flags) { } function setErrNo(value) { HEAP32[___errno_location() >> 2] = value; return value } function ___syscall_fcntl64(fd, cmd, varargs) { SYSCALLS.varargs = varargs; return 0 } function ___syscall_ioctl(fd, op, varargs) { SYSCALLS.varargs = varargs; return 0 } function ___syscall_lstat64(path, buf) { } function ___syscall_openat(dirfd, path, flags, varargs) { SYSCALLS.varargs = varargs } function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) { } function ___syscall_rmdir(path) { } function ___syscall_unlinkat(dirfd, path, flags) { } function __emscripten_date_now() { return 0 } /* disable access to date.now */ const nowIsMonotonic = true; function __emscripten_get_now_is_monotonic() { return nowIsMonotonic } function __emscripten_throw_longjmp() { throw Infinity } function __gmtime_js(time, tmPtr) { const date = new Date(HEAP32[time >> 2] * 1e3); HEAP32[tmPtr >> 2] = date.getUTCSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getUTCHours(); HEAP32[tmPtr + 12 >> 2] = date.getUTCDate(); HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth(); HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900; HEAP32[tmPtr + 24 >> 2] = date.getUTCDay(); const start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0); const yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0; HEAP32[tmPtr + 28 >> 2] = yday } function __localtime_js(time, tmPtr) { const date = new Date(HEAP32[time >> 2] * 1e3); HEAP32[tmPtr >> 2] = date.getSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getHours(); HEAP32[tmPtr + 12 >> 2] = date.getDate(); HEAP32[tmPtr + 16 >> 2] = date.getMonth(); HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900; HEAP32[tmPtr + 24 >> 2] = date.getDay(); const start = new Date(date.getFullYear(), 0, 1); const yday = (date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24) | 0; HEAP32[tmPtr + 28 >> 2] = yday; HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60); const summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset(); const winterOffset = start.getTimezoneOffset(); const dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0; HEAP32[tmPtr + 32 >> 2] = dst } function __mktime_js(tmPtr) { const date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0); const dst = HEAP32[tmPtr + 32 >> 2]; const guessedOffset = date.getTimezoneOffset(); const start = new Date(date.getFullYear(), 0, 1); const summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset(); const winterOffset = start.getTimezoneOffset(); const dstOffset = Math.min(winterOffset, summerOffset); if (dst < 0) { HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset) } else if (dst > 0 != (dstOffset == guessedOffset)) { const nonDstOffset = Math.max(winterOffset, summerOffset); const trueOffset = dst > 0 ? dstOffset : nonDstOffset; date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4) } HEAP32[tmPtr + 24 >> 2] = date.getDay(); const yday = (date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24) | 0; HEAP32[tmPtr + 28 >> 2] = yday; HEAP32[tmPtr >> 2] = date.getSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getHours(); HEAP32[tmPtr + 12 >> 2] = date.getDate(); HEAP32[tmPtr + 16 >> 2] = date.getMonth(); return date.getTime() / 1e3 | 0 } function _tzset_impl(timezone, daylight, tzname) { const currentYear = (new Date()).getFullYear(); const winter = new Date(currentYear, 0, 1); const summer = new Date(currentYear, 6, 1); const winterOffset = winter.getTimezoneOffset(); const summerOffset = summer.getTimezoneOffset(); const stdTimezoneOffset = Math.max(winterOffset, summerOffset); HEAP32[timezone >> 2] = stdTimezoneOffset * 60; HEAP32[daylight >> 2] = Number(winterOffset != summerOffset); function extractZone(date) { const match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/); return match ? match[1] : 'GMT' } const winterName = extractZone(winter); const summerName = extractZone(summer); const winterNamePtr = allocateUTF8(winterName); const summerNamePtr = allocateUTF8(summerName); if (summerOffset < winterOffset) { HEAPU32[tzname >> 2] = winterNamePtr; HEAPU32[tzname + 4 >> 2] = summerNamePtr } else { HEAPU32[tzname >> 2] = summerNamePtr; HEAPU32[tzname + 4 >> 2] = winterNamePtr } } function __tzset_js(timezone, daylight, tzname) { if (__tzset_js.called) return; __tzset_js.called = true; _tzset_impl(timezone, daylight, tzname) } function _abort() { abort('') } let _emscripten_get_now; if (ENVIRONMENT_IS_NODE) { _emscripten_get_now = () => { return 0 } } else _emscripten_get_now = () => 0; function _emscripten_memcpy_big(dest, src, num) { HEAPU8.copyWithin(dest, src, src + num) } function getHeapMax() { return 524288e3 } function emscripten_realloc_buffer(size) { try { wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16); updateGlobalBufferAndViews(wasmMemory.buffer); return 1 } catch (e) { } } function _emscripten_resize_heap(requestedSize) { const oldSize = HEAPU8.length; requestedSize = requestedSize >>> 0; const maxHeapSize = getHeapMax(); if (requestedSize > maxHeapSize) { return false } const alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple; for (let cutDown = 1; cutDown <= 4; cutDown *= 2) { let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296); const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)); const replacement = emscripten_realloc_buffer(newSize); if (replacement) { return true } } return false } const ENV = {}; function getExecutableName() { return thisProgram || './this.program' } function getEnvStrings() { if (!getEnvStrings.strings) { const lang = 'C.UTF-8'; const env = { USER: 'web_user', LOGNAME: 'web_user', PATH: '/', PWD: '/', HOME: '/home/web_user', LANG: lang, _: getExecutableName() }; for (var x in ENV) { if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x] } const strings = []; for (var x in env) { strings.push(x + '=' + env[x]) } getEnvStrings.strings = strings } return getEnvStrings.strings } function _environ_get(__environ, environ_buf) { let bufSize = 0; getEnvStrings().forEach(function (string, i) { const ptr = environ_buf + bufSize; HEAPU32[__environ + i * 4 >> 2] = ptr; writeAsciiToMemory(string, ptr); bufSize += string.length + 1 }); return 0 } function _environ_sizes_get(penviron_count, penviron_buf_size) { const strings = getEnvStrings(); HEAPU32[penviron_count >> 2] = strings.length; let bufSize = 0; strings.forEach(function (string) { bufSize += string.length + 1 }); HEAPU32[penviron_buf_size >> 2] = bufSize; return 0 } function _exit(status) { exit(status) } function _fd_close(fd) { return 52 } function _fd_read(fd, iov, iovcnt, pnum) { return 52 } function _fd_seek(fd, offset_low, offset_high, whence, newOffset) { return 70 } const printCharBuffers = [null, [], []]; function printChar(stream, curr) { const buffer = printCharBuffers[stream]; if (curr === 0 || curr === 10) { (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0)); buffer.length = 0 } else { buffer.push(curr) } } function _fd_write(fd, iov, iovcnt, pnum) { let num = 0; for (let i = 0; i < iovcnt; i++) { const ptr = HEAPU32[iov >> 2]; const len = HEAPU32[iov + 4 >> 2]; iov += 8; for (let j = 0; j < len; j++) { printChar(fd, HEAPU8[ptr + j]) } num += len } HEAPU32[pnum >> 2] = num; return 0 } function _getTempRet0() { return getTempRet0() } function _setTempRet0(val) { setTempRet0(val) } function __isLeapYear(year) { return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) } function __arraySum(array, index) { let sum = 0; for (let i = 0; i <= index; sum += array[i++]) { } return sum } const __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; const __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function __addDays(date, days) { const newDate = new Date(date.getTime()); while (days > 0) { const leap = __isLeapYear(newDate.getFullYear()); const currentMonth = newDate.getMonth(); const daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth]; if (days > daysInCurrentMonth - newDate.getDate()) { days -= daysInCurrentMonth - newDate.getDate() + 1; newDate.setDate(1); if (currentMonth < 11) { newDate.setMonth(currentMonth + 1) } else { newDate.setMonth(0); newDate.setFullYear(newDate.getFullYear() + 1) } } else { newDate.setDate(newDate.getDate() + days); return newDate } } return newDate } function _strftime(s, maxsize, format, tm) { const tm_zone = HEAP32[tm + 40 >> 2]; const date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : '' }; let pattern = UTF8ToString(format); const EXPANSION_RULES_1 = { '%c': '%a %b %d %H:%M:%S %Y', '%D': '%m/%d/%y', '%F': '%Y-%m-%d', '%h': '%b', '%r': '%I:%M:%S %p', '%R': '%H:%M', '%T': '%H:%M:%S', '%x': '%m/%d/%y', '%X': '%H:%M:%S', '%Ec': '%c', '%EC': '%C', '%Ex': '%m/%d/%y', '%EX': '%H:%M:%S', '%Ey': '%y', '%EY': '%Y', '%Od': '%d', '%Oe': '%e', '%OH': '%H', '%OI': '%I', '%Om': '%m', '%OM': '%M', '%OS': '%S', '%Ou': '%u', '%OU': '%U', '%OV': '%V', '%Ow': '%w', '%OW': '%W', '%Oy': '%y' }; for (var rule in EXPANSION_RULES_1) { pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]) } const WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; const MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']; function leadingSomething(value, digits, character) { let str = typeof value === 'number' ? value.toString() : value || ''; while (str.length < digits) { str = character[0] + str } return str } function leadingNulls(value, digits) { return leadingSomething(value, digits, '0') } function compareByDay(date1, date2) { function sgn(value) { return value < 0 ? -1 : value > 0 ? 1 : 0 } let compare; if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) { if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) { compare = sgn(date1.getDate() - date2.getDate()) } } return compare } function getFirstWeekStartDate(janFourth) { switch (janFourth.getDay()) { case 0: return new Date(janFourth.getFullYear() - 1, 11, 29); case 1: return janFourth; case 2: return new Date(janFourth.getFullYear(), 0, 3); case 3: return new Date(janFourth.getFullYear(), 0, 2); case 4: return new Date(janFourth.getFullYear(), 0, 1); case 5: return new Date(janFourth.getFullYear() - 1, 11, 31); case 6: return new Date(janFourth.getFullYear() - 1, 11, 30) } } function getWeekBasedYear(date) { const thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday); const janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4); const janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4); const firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear); const firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear); if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) { if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) { return thisDate.getFullYear() + 1 } else { return thisDate.getFullYear() } } else { return thisDate.getFullYear() - 1 } } const EXPANSION_RULES_2 = { '%a': function (date) { return WEEKDAYS[date.tm_wday].substring(0, 3) }, '%A': function (date) { return WEEKDAYS[date.tm_wday] }, '%b': function (date) { return MONTHS[date.tm_mon].substring(0, 3) }, '%B': function (date) { return MONTHS[date.tm_mon] }, '%C': function (date) { const year = date.tm_year + 1900; return leadingNulls(year / 100 | 0, 2) }, '%d': function (date) { return leadingNulls(date.tm_mday, 2) }, '%e': function (date) { return leadingSomething(date.tm_mday, 2, ' ') }, '%g': function (date) { return getWeekBasedYear(date).toString().substring(2) }, '%G': function (date) { return getWeekBasedYear(date) }, '%H': function (date) { return leadingNulls(date.tm_hour, 2) }, '%I': function (date) { let twelveHour = date.tm_hour; if (twelveHour == 0) twelveHour = 12; else if (twelveHour > 12) twelveHour -= 12; return leadingNulls(twelveHour, 2) }, '%j': function (date) { return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3) }, '%m': function (date) { return leadingNulls(date.tm_mon + 1, 2) }, '%M': function (date) { return leadingNulls(date.tm_min, 2) }, '%n': function () { return '\n' }, '%p': function (date) { if (date.tm_hour >= 0 && date.tm_hour < 12) { return 'AM' } else { return 'PM' } }, '%S': function (date) { return leadingNulls(date.tm_sec, 2) }, '%t': function () { return '\t' }, '%u': function (date) { return date.tm_wday || 7 }, '%U': function (date) { const days = date.tm_yday + 7 - date.tm_wday; return leadingNulls(Math.floor(days / 7), 2) }, '%V': function (date) { let val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7); if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) { val++ } if (!val) { val = 52; const dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7; if (dec31 == 4 || dec31 == 5 && __isLeapYear(date.tm_year % 400 - 1)) { val++ } } else if (val == 53) { const jan1 = (date.tm_wday + 371 - date.tm_yday) % 7; if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year))) val = 1 } return leadingNulls(val, 2) }, '%w': function (date) { return date.tm_wday }, '%W': function (date) { const days = date.tm_yday + 7 - (date.tm_wday + 6) % 7; return leadingNulls(Math.floor(days / 7), 2) }, '%y': function (date) { return (date.tm_year + 1900).toString().substring(2) }, '%Y': function (date) { return date.tm_year + 1900 }, '%z': function (date) { let off = date.tm_gmtoff; const ahead = off >= 0; off = Math.abs(off) / 60; off = off / 60 * 100 + off % 60; return (ahead ? '+' : '-') + String('0000' + off).slice(-4) }, '%Z': function (date) { return date.tm_zone }, '%%': function () { return '%' } }; pattern = pattern.replace(/%%/g, '\0\0'); for (var rule in EXPANSION_RULES_2) { if (pattern.includes(rule)) { pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date)) } } pattern = pattern.replace(/\0\0/g, '%'); const bytes = intArrayFromString(pattern, false); if (bytes.length > maxsize) { return 0 } writeArrayToMemory(bytes, s); return bytes.length - 1 } function _system(command) { if (ENVIRONMENT_IS_NODE) { if (!command) return 1; const cmdstr = UTF8ToString(command); if (!cmdstr.length) return 0; const cp = require('child_process'); const ret = cp.spawnSync(cmdstr, [], { shell: true, stdio: 'inherit' }); const _W_EXITCODE = (ret, sig) => ret << 8 | sig; if (ret.status === null) { const signalToNumber = sig => { switch (sig) { case 'SIGHUP': return 1; case 'SIGINT': return 2; case 'SIGQUIT': return 3; case 'SIGFPE': return 8; case 'SIGKILL': return 9; case 'SIGALRM': return 14; case 'SIGTERM': return 15 } return 2 }; return _W_EXITCODE(0, signalToNumber(ret.signal)) } return _W_EXITCODE(ret.status, 0) } if (!command) return 0; setErrNo(52); return -1 } function intArrayFromString(stringy, dontAddNull, length) { const len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; const u8array = new Array(len); const numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull) u8array.length = numBytesWritten; return u8array } var asmLibraryArg = { w: ___syscall_dup3, d: ___syscall_fcntl64, z: ___syscall_ioctl, r: ___syscall_lstat64, g: ___syscall_openat, s: ___syscall_renameat, t: ___syscall_rmdir, e: ___syscall_unlinkat, a: __emscripten_date_now, A: __emscripten_get_now_is_monotonic, p: __emscripten_throw_longjmp, B: __gmtime_js, C: __localtime_js, i: __mktime_js, j: __tzset_js, D: _abort, k: _emscripten_memcpy_big, q: _emscripten_resize_heap, u: _environ_get, v: _environ_sizes_get, l: _exit, c: _fd_close, y: _fd_read, o: _fd_seek, f: _fd_write, h: _getTempRet0, x: invoke_vii, b: _setTempRet0, n: _strftime, m: _system }; const asm = createWasm(); var ___wasm_call_ctors = Module.___wasm_call_ctors = function () { return (___wasm_call_ctors = Module.___wasm_call_ctors = Module.asm.F).apply(null, arguments) }; var _handle = Module._handle = function () { return (_handle = Module._handle = Module.asm.G).apply(null, arguments) }; var _main = Module._main = function () { return (_main = Module._main = Module.asm.H).apply(null, arguments) }; var _malloc = Module._malloc = function () { return (_malloc = Module._malloc = Module.asm.J).apply(null, arguments) }; var ___errno_location = Module.___errno_location = function () { return (___errno_location = Module.___errno_location = Module.asm.K).apply(null, arguments) }; var _setThrew = Module._setThrew = function () { return (_setThrew = Module._setThrew = Module.asm.L).apply(null, arguments) }; var stackSave = Module.stackSave = function () { return (stackSave = Module.stackSave = Module.asm.M).apply(null, arguments) }; var stackRestore = Module.stackRestore = function () { return (stackRestore = Module.stackRestore = Module.asm.N).apply(null, arguments) }; var stackAlloc = Module.stackAlloc = function () { return (stackAlloc = Module.stackAlloc = Module.asm.O).apply(null, arguments) }; function invoke_vii(index, a1, a2) { const sp = stackSave(); try { getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } let MAGIC = 0; Math.random = () => { MAGIC = Math.pow(MAGIC + 1.8912, 3) % 1; return MAGIC }; let TIME = 1e4; Date.now = () => TIME++; if (typeof performance === 'object') performance.now = Date.now; if (ENVIRONMENT_IS_NODE) process.hrtime = Date.now; if (!Module) Module = {}; Module.thisProgram = 'thisProgram'; Module.cwrap = cwrap; let calledRun; function ExitStatus(status) { this.name = 'ExitStatus'; this.message = 'Program terminated with exit(' + status + ')'; this.status = status } let calledMain = false; dependenciesFulfilled = function runCaller() { if (!calledRun) run(); if (!calledRun) dependenciesFulfilled = runCaller }; function callMain(args) { const entryFunction = Module._main; const argc = 0; const argv = 0; try { const ret = entryFunction(argc, argv); exit(ret, true); return ret } catch (e) { return handleException(e) } finally { calledMain = true } } function run(args) { args = args || arguments_; if (runDependencies > 0) { return } preRun(); if (runDependencies > 0) { return } function doRun() { if (calledRun) return; calledRun = true; Module.calledRun = true; if (ABORT) return; initRuntime(); preMain(); readyPromiseResolve(Module); if (Module.onRuntimeInitialized) Module.onRuntimeInitialized(); if (shouldRunNow) callMain(args); postRun() } if (Module.setStatus) { Module.setStatus('Running...'); setTimeout(function () { setTimeout(function () { Module.setStatus('') }, 1); doRun() }, 1) } else { doRun() } } Module.run = run; function exit(status, implicit) { EXITSTATUS = status; procExit(status) } function procExit(code) { EXITSTATUS = code; if (!keepRuntimeAlive()) { if (Module.onExit) Module.onExit(code); ABORT = true } quit_(code, new ExitStatus(code)) } if (Module.preInit) { if (typeof Module.preInit === 'function') Module.preInit = [Module.preInit]; while (Module.preInit.length > 0) { Module.preInit.pop()() } } var shouldRunNow = true; if (Module.noInitialRun) shouldRunNow = false; run()

      /**
       * Expose the ability to resize the WASM heap.
       * 
       * The WASM heap is set to auto-grow, but starts with an initial small size.
       * If we try to load a previously obtained heap, that is larger than the initial size
       * due to it having been auto-grown, we will receive an RangeError due to the initial
       * size being too small to store our heap
       * 
       * Exposing resize_heap allows us to expand the initial size, if needed, before loading in our heap.
       */
      Module.resizeHeap = _emscripten_resize_heap

      return Module.ready
    }
  )
})();

module.exports = Module