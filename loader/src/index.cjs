const DEFAULT_GAS_LIMIT = 9_000_000_000

/* eslint-disable */
const Module = (() => {
  let _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename
  return (
    function (binary, _limit) {
      var Module = Module || {}
      Module.wasmBinary = binary // metering.meterWASM(binary, { meterType: 'i32' }).module

      /**
       * Expose gas on the module
       * 
       * This is how we track the amount of ops this WASM module has used,
       * and also how we refill the gas on each invocation of the WASM.
       */
      Module.gas = {
        limit: _limit || DEFAULT_GAS_LIMIT,
        used: 0,
        use: (amount) => {
          Module.gas.used += amount
        },
        refill: (amount) => {
          if (!amount) Module.gas.used = 0
          else Module.gas.used = Math.max(Module.gas.used - amount, 0)
        },
        isEmpty: () => Module.gas.used > Module.gas.limit
      }

      /**
       * See this issue with emscripten https://github.com/emscripten-core/emscripten/issues/12740
       *
       * We need to manually cleanup any listeners that are setup as part of the WASM module,
       * so that they can be deregistered later and the associated WASM memory can be garbage collected
       *
       * This is custom code we've added to the emscripten module code.
       */
      const _listeners_ = []
      Module.cleanupListeners = function () {
        /**
         * Deregister any listeners that did not exist before this
         * WASM module was bootstrapped
         */
        _listeners_.forEach(([name, l]) => process.removeListener(name, l))
      }
      function uncaughtException (ex) { if (!(ex instanceof ExitStatus)) { throw ex } }
      function unhandledRejection (reason) { throw reason }
      _listeners_.push(['uncaughtException', uncaughtException], ['unhandledRejection', unhandledRejection])

      var Module = typeof Module !== 'undefined' ? Module : {}; let readyPromiseResolve, readyPromiseReject; Module.ready = new Promise(function (resolve, reject) { readyPromiseResolve = resolve; readyPromiseReject = reject }); Module.locateFile = url => { return url }; let moduleOverrides = Object.assign({}, Module); let arguments_ = []; let thisProgram = './this.program'; let quit_ = (status, toThrow) => { throw toThrow }; const ENVIRONMENT_IS_WEB = typeof window === 'object'; const ENVIRONMENT_IS_WORKER = typeof importScripts === 'function'; const ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string'; let scriptDirectory = ''; function locateFile (path) { if (Module.locateFile) { return Module.locateFile(path, scriptDirectory) } return scriptDirectory + path } let read_, readAsync, readBinary, setWindowTitle; function logExceptionOnExit (e) { if (e instanceof ExitStatus) return; const toLog = e; err('exiting due to exception: ' + toLog) } let fs; let nodePath; let requireNodeFS; if (ENVIRONMENT_IS_NODE) { if (ENVIRONMENT_IS_WORKER) { scriptDirectory = require('path').dirname(scriptDirectory) + '/' } else { scriptDirectory = __dirname + '/' }requireNodeFS = () => { if (!nodePath) { fs = require('fs'); nodePath = require('path') } }; read_ = function shell_read (filename, binary) { requireNodeFS(); filename = nodePath.normalize(filename); return fs.readFileSync(filename, binary ? undefined : 'utf8') }; readBinary = filename => { let ret = read_(filename, true); if (!ret.buffer) { ret = new Uint8Array(ret) } return ret }; readAsync = (filename, onload, onerror) => { requireNodeFS(); filename = nodePath.normalize(filename); fs.readFile(filename, function (err, data) { if (err)onerror(err); else onload(data.buffer) }) }; if (process.argv.length > 1) { thisProgram = process.argv[1].replace(/\\/g, '/') }arguments_ = process.argv.slice(2); process.on('uncaughtException', uncaughtException); process.on('unhandledRejection', unhandledRejection); quit_ = (status, toThrow) => { if (keepRuntimeAlive()) { process.exitCode = status; throw toThrow }logExceptionOnExit(toThrow); process.exit(status) }; Module.inspect = function () { return '[Emscripten Module object]' } } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { if (ENVIRONMENT_IS_WORKER) { scriptDirectory = self.location.href } else if (typeof document !== 'undefined' && document.currentScript) { scriptDirectory = document.currentScript.src } if (_scriptDir) { scriptDirectory = _scriptDir } if (scriptDirectory.indexOf('blob:') !== 0) { scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1) } else { scriptDirectory = '' } { read_ = url => { const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.send(null); return xhr.responseText }; if (ENVIRONMENT_IS_WORKER) { readBinary = url => { const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.responseType = 'arraybuffer'; xhr.send(null); return new Uint8Array(xhr.response) } }readAsync = (url, onload, onerror) => { const xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.responseType = 'arraybuffer'; xhr.onload = () => { if (xhr.status == 200 || xhr.status == 0 && xhr.response) { onload(xhr.response); return }onerror() }; xhr.onerror = onerror; xhr.send(null) } }setWindowTitle = title => document.title = title } else {} const out = Module.print || console.log.bind(console); var err = Module.printErr || console.warn.bind(console); Object.assign(Module, moduleOverrides); moduleOverrides = null; if (Module.arguments)arguments_ = Module.arguments; if (Module.thisProgram)thisProgram = Module.thisProgram; if (Module.quit)quit_ = Module.quit; let tempRet0 = 0; const setTempRet0 = value => { tempRet0 = value }; const getTempRet0 = () => tempRet0; let wasmBinary; if (Module.wasmBinary)wasmBinary = Module.wasmBinary; const noExitRuntime = Module.noExitRuntime || true; if (typeof WebAssembly !== 'object') { abort('no native wasm support detected') } let wasmMemory; let ABORT = false; let EXITSTATUS; function getCFunc (ident) { const func = Module['_' + ident]; return func } function ccall (ident, returnType, argTypes, args, opts) { const toC = { string: function (str) { let ret = 0; if (str !== null && str !== undefined && str !== 0) { const len = (str.length << 2) + 1; ret = stackAlloc(len); stringToUTF8(str, ret, len) } return ret }, array: function (arr) { const ret = stackAlloc(arr.length); writeArrayToMemory(arr, ret); return ret } }; function convertReturnValue (ret) { if (returnType === 'string') { return UTF8ToString(ret) } if (returnType === 'boolean') return Boolean(ret); return ret } const func = getCFunc(ident); const cArgs = []; let stack = 0; if (args) { for (let i = 0; i < args.length; i++) { const converter = toC[argTypes[i]]; if (converter) { if (stack === 0)stack = stackSave(); cArgs[i] = converter(args[i]) } else { cArgs[i] = args[i] } } } let ret = func.apply(null, cArgs); function onDone (ret) { if (stack !== 0)stackRestore(stack); return convertReturnValue(ret) }ret = onDone(ret); return ret } function cwrap (ident, returnType, argTypes, opts) { argTypes = argTypes || []; const numericArgs = argTypes.every(function (type) { return type === 'number' }); const numericRet = returnType !== 'string'; if (numericRet && numericArgs && !opts) { return getCFunc(ident) } return function () { return ccall(ident, returnType, argTypes, arguments, opts) } } const UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined; function UTF8ArrayToString (heapOrArray, idx, maxBytesToRead) { const endIdx = idx + maxBytesToRead; let endPtr = idx; while (heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr; if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) { return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr)) } else { var str = ''; while (idx < endPtr) { let u0 = heapOrArray[idx++]; if (!(u0 & 128)) { str += String.fromCharCode(u0); continue } const u1 = heapOrArray[idx++] & 63; if ((u0 & 224) == 192) { str += String.fromCharCode((u0 & 31) << 6 | u1); continue } const u2 = heapOrArray[idx++] & 63; if ((u0 & 240) == 224) { u0 = (u0 & 15) << 12 | u1 << 6 | u2 } else { u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63 } if (u0 < 65536) { str += String.fromCharCode(u0) } else { const ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } } } return str } function UTF8ToString (ptr, maxBytesToRead) { return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '' } function stringToUTF8Array (str, heap, outIdx, maxBytesToWrite) { if (!(maxBytesToWrite > 0)) return 0; const startIdx = outIdx; const endIdx = outIdx + maxBytesToWrite - 1; for (let i = 0; i < str.length; ++i) { let u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) { const u1 = str.charCodeAt(++i); u = 65536 + ((u & 1023) << 10) | u1 & 1023 } if (u <= 127) { if (outIdx >= endIdx) break; heap[outIdx++] = u } else if (u <= 2047) { if (outIdx + 1 >= endIdx) break; heap[outIdx++] = 192 | u >> 6; heap[outIdx++] = 128 | u & 63 } else if (u <= 65535) { if (outIdx + 2 >= endIdx) break; heap[outIdx++] = 224 | u >> 12; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } else { if (outIdx + 3 >= endIdx) break; heap[outIdx++] = 240 | u >> 18; heap[outIdx++] = 128 | u >> 12 & 63; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } }heap[outIdx] = 0; return outIdx - startIdx } function stringToUTF8 (str, outPtr, maxBytesToWrite) { return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite) } function lengthBytesUTF8 (str) { let len = 0; for (let i = 0; i < str.length; ++i) { let u = str.charCodeAt(i); if (u >= 55296 && u <= 57343)u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023; if (u <= 127)++len; else if (u <= 2047)len += 2; else if (u <= 65535)len += 3; else len += 4 } return len } function allocateUTF8 (str) { const size = lengthBytesUTF8(str) + 1; const ret = _malloc(size); if (ret)stringToUTF8Array(str, HEAP8, ret, size); return ret } function writeArrayToMemory (array, buffer) { HEAP8.set(array, buffer) } function writeAsciiToMemory (str, buffer, dontAddNull) { for (let i = 0; i < str.length; ++i) { HEAP8[buffer++ >> 0] = str.charCodeAt(i) } if (!dontAddNull)HEAP8[buffer >> 0] = 0 } let buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64; function updateGlobalBufferAndViews (buf) { buffer = buf; Module.HEAP8 = HEAP8 = new Int8Array(buf); Module.HEAP16 = HEAP16 = new Int16Array(buf); Module.HEAP32 = HEAP32 = new Int32Array(buf); Module.HEAPU8 = HEAPU8 = new Uint8Array(buf); Module.HEAPU16 = HEAPU16 = new Uint16Array(buf); Module.HEAPU32 = HEAPU32 = new Uint32Array(buf); Module.HEAPF32 = HEAPF32 = new Float32Array(buf); Module.HEAPF64 = HEAPF64 = new Float64Array(buf) } const INITIAL_MEMORY = Module.INITIAL_MEMORY || 6291456; let wasmTable; const __ATPRERUN__ = []; const __ATINIT__ = []; const __ATMAIN__ = []; const __ATPOSTRUN__ = []; let runtimeInitialized = false; function keepRuntimeAlive () { return noExitRuntime } function preRun () { if (Module.preRun) { if (typeof Module.preRun === 'function')Module.preRun = [Module.preRun]; while (Module.preRun.length) { addOnPreRun(Module.preRun.shift()) } }callRuntimeCallbacks(__ATPRERUN__) } function initRuntime () { runtimeInitialized = true; callRuntimeCallbacks(__ATINIT__) } function preMain () { callRuntimeCallbacks(__ATMAIN__) } function postRun () { if (Module.postRun) { if (typeof Module.postRun === 'function')Module.postRun = [Module.postRun]; while (Module.postRun.length) { addOnPostRun(Module.postRun.shift()) } }callRuntimeCallbacks(__ATPOSTRUN__) } function addOnPreRun (cb) { __ATPRERUN__.unshift(cb) } function addOnInit (cb) { __ATINIT__.unshift(cb) } function addOnPostRun (cb) { __ATPOSTRUN__.unshift(cb) } let runDependencies = 0; let runDependencyWatcher = null; let dependenciesFulfilled = null; function addRunDependency (id) { runDependencies++; if (Module.monitorRunDependencies) { Module.monitorRunDependencies(runDependencies) } } function removeRunDependency (id) { runDependencies--; if (Module.monitorRunDependencies) { Module.monitorRunDependencies(runDependencies) } if (runDependencies == 0) { if (runDependencyWatcher !== null) { clearInterval(runDependencyWatcher); runDependencyWatcher = null } if (dependenciesFulfilled) { const callback = dependenciesFulfilled; dependenciesFulfilled = null; callback() } } } function abort (what) { { if (Module.onAbort) { Module.onAbort(what) } }what = 'Aborted(' + what + ')'; err(what); ABORT = true; EXITSTATUS = 1; what += '. Build with -sASSERTIONS for more info.'; const e = new WebAssembly.RuntimeError(what); readyPromiseReject(e); throw e } const dataURIPrefix = 'data:application/octet-stream;base64,'; function isDataURI (filename) { return filename.startsWith(dataURIPrefix) } function isFileURI (filename) { return filename.startsWith('file://') } let wasmBinaryFile; wasmBinaryFile = 'process.wasm'; if (!isDataURI(wasmBinaryFile)) { wasmBinaryFile = locateFile(wasmBinaryFile) } function getBinary (file) { try { if (file == wasmBinaryFile && wasmBinary) { return new Uint8Array(wasmBinary) } if (readBinary) { return readBinary(file) } else { throw 'both async and sync fetching of the wasm failed' } } catch (err) { abort(err) } } function getBinaryPromise () { if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) { if (typeof fetch === 'function' && !isFileURI(wasmBinaryFile)) { return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) { if (!response.ok) { throw "failed to load wasm binary file at '" + wasmBinaryFile + "'" } return response.arrayBuffer() }).catch(function () { return getBinary(wasmBinaryFile) }) } else { if (readAsync) { return new Promise(function (resolve, reject) { readAsync(wasmBinaryFile, function (response) { resolve(new Uint8Array(response)) }, reject) }) } } } return Promise.resolve().then(function () { return getBinary(wasmBinaryFile) }) } function createWasm () { const info = { a: asmLibraryArg, metering: { usegas: function (gas) { Module.gas.use(gas); if (Module.gas.isEmpty()) throw Error('out of gas!') } } }; function receiveInstance (instance, module) { const exports = instance.exports; Module.asm = exports; wasmMemory = Module.asm.E; updateGlobalBufferAndViews(wasmMemory.buffer); wasmTable = Module.asm.I; addOnInit(Module.asm.F); removeRunDependency('wasm-instantiate') }addRunDependency('wasm-instantiate'); function receiveInstantiationResult (result) { receiveInstance(result.instance) } function instantiateArrayBuffer (receiver) { return getBinaryPromise().then(function (binary) { return WebAssembly.instantiate(binary, info) }).then(function (instance) { return instance }).then(receiver, function (reason) { err('failed to asynchronously prepare wasm: ' + reason); abort(reason) }) } function instantiateAsync () { if (!wasmBinary && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch === 'function') { return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) { const result = WebAssembly.instantiateStreaming(response, info); return result.then(receiveInstantiationResult, function (reason) { err('wasm streaming compile failed: ' + reason); err('falling back to ArrayBuffer instantiation'); return instantiateArrayBuffer(receiveInstantiationResult) }) }) } else { return instantiateArrayBuffer(receiveInstantiationResult) } } if (Module.instantiateWasm) { try { const exports = Module.instantiateWasm(info, receiveInstance); return exports } catch (e) { err('Module.instantiateWasm callback failed with error: ' + e); return false } }instantiateAsync().catch(readyPromiseReject); return {} } function callRuntimeCallbacks (callbacks) { while (callbacks.length > 0) { const callback = callbacks.shift(); if (typeof callback === 'function') { callback(Module); continue } const func = callback.func; if (typeof func === 'number') { if (callback.arg === undefined) { getWasmTableEntry(func)() } else { getWasmTableEntry(func)(callback.arg) } } else { func(callback.arg === undefined ? null : callback.arg) } } } function getWasmTableEntry (funcPtr) { return wasmTable.get(funcPtr) } function handleException (e) { if (e instanceof ExitStatus || e == 'unwind') { return EXITSTATUS }quit_(1, e) } var SYSCALLS = { varargs: undefined, get: function () { SYSCALLS.varargs += 4; const ret = HEAP32[SYSCALLS.varargs - 4 >> 2]; return ret }, getStr: function (ptr) { const ret = UTF8ToString(ptr); return ret } }; function ___syscall_dup3 (fd, suggestFD, flags) {} function setErrNo (value) { HEAP32[___errno_location() >> 2] = value; return value } function ___syscall_fcntl64 (fd, cmd, varargs) { SYSCALLS.varargs = varargs; return 0 } function ___syscall_ioctl (fd, op, varargs) { SYSCALLS.varargs = varargs; return 0 } function ___syscall_lstat64 (path, buf) {} function ___syscall_openat (dirfd, path, flags, varargs) { SYSCALLS.varargs = varargs } function ___syscall_renameat (olddirfd, oldpath, newdirfd, newpath) {} function ___syscall_rmdir (path) {} function ___syscall_unlinkat (dirfd, path, flags) {} function __emscripten_date_now () { return Date.now() } const nowIsMonotonic = true; function __emscripten_get_now_is_monotonic () { return nowIsMonotonic } function __emscripten_throw_longjmp () { throw Infinity } function __gmtime_js (time, tmPtr) { const date = new Date(HEAP32[time >> 2] * 1e3); HEAP32[tmPtr >> 2] = date.getUTCSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getUTCHours(); HEAP32[tmPtr + 12 >> 2] = date.getUTCDate(); HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth(); HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900; HEAP32[tmPtr + 24 >> 2] = date.getUTCDay(); const start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0); const yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0; HEAP32[tmPtr + 28 >> 2] = yday } function __localtime_js (time, tmPtr) { const date = new Date(HEAP32[time >> 2] * 1e3); HEAP32[tmPtr >> 2] = date.getSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getHours(); HEAP32[tmPtr + 12 >> 2] = date.getDate(); HEAP32[tmPtr + 16 >> 2] = date.getMonth(); HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900; HEAP32[tmPtr + 24 >> 2] = date.getDay(); const start = new Date(date.getFullYear(), 0, 1); const yday = (date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24) | 0; HEAP32[tmPtr + 28 >> 2] = yday; HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60); const summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset(); const winterOffset = start.getTimezoneOffset(); const dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0; HEAP32[tmPtr + 32 >> 2] = dst } function __mktime_js (tmPtr) { const date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0); const dst = HEAP32[tmPtr + 32 >> 2]; const guessedOffset = date.getTimezoneOffset(); const start = new Date(date.getFullYear(), 0, 1); const summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset(); const winterOffset = start.getTimezoneOffset(); const dstOffset = Math.min(winterOffset, summerOffset); if (dst < 0) { HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset) } else if (dst > 0 != (dstOffset == guessedOffset)) { const nonDstOffset = Math.max(winterOffset, summerOffset); const trueOffset = dst > 0 ? dstOffset : nonDstOffset; date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4) }HEAP32[tmPtr + 24 >> 2] = date.getDay(); const yday = (date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24) | 0; HEAP32[tmPtr + 28 >> 2] = yday; HEAP32[tmPtr >> 2] = date.getSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getHours(); HEAP32[tmPtr + 12 >> 2] = date.getDate(); HEAP32[tmPtr + 16 >> 2] = date.getMonth(); return date.getTime() / 1e3 | 0 } function _tzset_impl (timezone, daylight, tzname) { const currentYear = (new Date()).getFullYear(); const winter = new Date(currentYear, 0, 1); const summer = new Date(currentYear, 6, 1); const winterOffset = winter.getTimezoneOffset(); const summerOffset = summer.getTimezoneOffset(); const stdTimezoneOffset = Math.max(winterOffset, summerOffset); HEAP32[timezone >> 2] = stdTimezoneOffset * 60; HEAP32[daylight >> 2] = Number(winterOffset != summerOffset); function extractZone (date) { const match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/); return match ? match[1] : 'GMT' } const winterName = extractZone(winter); const summerName = extractZone(summer); const winterNamePtr = allocateUTF8(winterName); const summerNamePtr = allocateUTF8(summerName); if (summerOffset < winterOffset) { HEAPU32[tzname >> 2] = winterNamePtr; HEAPU32[tzname + 4 >> 2] = summerNamePtr } else { HEAPU32[tzname >> 2] = summerNamePtr; HEAPU32[tzname + 4 >> 2] = winterNamePtr } } function __tzset_js (timezone, daylight, tzname) { if (__tzset_js.called) return; __tzset_js.called = true; _tzset_impl(timezone, daylight, tzname) } function _abort () { abort('') } let _emscripten_get_now; if (ENVIRONMENT_IS_NODE) { _emscripten_get_now = () => { const t = process.hrtime(); return t[0] * 1e3 + t[1] / 1e6 } } else _emscripten_get_now = () => performance.now(); function _emscripten_memcpy_big (dest, src, num) { HEAPU8.copyWithin(dest, src, src + num) } function getHeapMax () { return 524288e3 } function emscripten_realloc_buffer (size) { try { wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16); updateGlobalBufferAndViews(wasmMemory.buffer); return 1 } catch (e) {} } function _emscripten_resize_heap (requestedSize) { const oldSize = HEAPU8.length; requestedSize = requestedSize >>> 0; const maxHeapSize = getHeapMax(); if (requestedSize > maxHeapSize) { return false } const alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple; for (let cutDown = 1; cutDown <= 4; cutDown *= 2) { let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296); const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)); const replacement = emscripten_realloc_buffer(newSize); if (replacement) { return true } } return false } const ENV = {}; function getExecutableName () { return thisProgram || './this.program' } function getEnvStrings () { if (!getEnvStrings.strings) { const lang = 'C.UTF-8'; const env = { USER: 'web_user', LOGNAME: 'web_user', PATH: '/', PWD: '/', HOME: '/home/web_user', LANG: lang, _: getExecutableName() }; for (var x in ENV) { if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x] } const strings = []; for (var x in env) { strings.push(x + '=' + env[x]) }getEnvStrings.strings = strings } return getEnvStrings.strings } function _environ_get (__environ, environ_buf) { let bufSize = 0; getEnvStrings().forEach(function (string, i) { const ptr = environ_buf + bufSize; HEAPU32[__environ + i * 4 >> 2] = ptr; writeAsciiToMemory(string, ptr); bufSize += string.length + 1 }); return 0 } function _environ_sizes_get (penviron_count, penviron_buf_size) { const strings = getEnvStrings(); HEAPU32[penviron_count >> 2] = strings.length; let bufSize = 0; strings.forEach(function (string) { bufSize += string.length + 1 }); HEAPU32[penviron_buf_size >> 2] = bufSize; return 0 } function _exit (status) { exit(status) } function _fd_close (fd) { return 52 } function _fd_read (fd, iov, iovcnt, pnum) { return 52 } function _fd_seek (fd, offset_low, offset_high, whence, newOffset) { return 70 } const printCharBuffers = [null, [], []]; function printChar (stream, curr) { const buffer = printCharBuffers[stream]; if (curr === 0 || curr === 10) { (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0)); buffer.length = 0 } else { buffer.push(curr) } } function _fd_write (fd, iov, iovcnt, pnum) { let num = 0; for (let i = 0; i < iovcnt; i++) { const ptr = HEAPU32[iov >> 2]; const len = HEAPU32[iov + 4 >> 2]; iov += 8; for (let j = 0; j < len; j++) { printChar(fd, HEAPU8[ptr + j]) }num += len }HEAPU32[pnum >> 2] = num; return 0 } function _getTempRet0 () { return getTempRet0() } function _setTempRet0 (val) { setTempRet0(val) } function __isLeapYear (year) { return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) } function __arraySum (array, index) { let sum = 0; for (let i = 0; i <= index; sum += array[i++]) {} return sum } const __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; const __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function __addDays (date, days) { const newDate = new Date(date.getTime()); while (days > 0) { const leap = __isLeapYear(newDate.getFullYear()); const currentMonth = newDate.getMonth(); const daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth]; if (days > daysInCurrentMonth - newDate.getDate()) { days -= daysInCurrentMonth - newDate.getDate() + 1; newDate.setDate(1); if (currentMonth < 11) { newDate.setMonth(currentMonth + 1) } else { newDate.setMonth(0); newDate.setFullYear(newDate.getFullYear() + 1) } } else { newDate.setDate(newDate.getDate() + days); return newDate } } return newDate } function _strftime (s, maxsize, format, tm) { const tm_zone = HEAP32[tm + 40 >> 2]; const date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : '' }; let pattern = UTF8ToString(format); const EXPANSION_RULES_1 = { '%c': '%a %b %d %H:%M:%S %Y', '%D': '%m/%d/%y', '%F': '%Y-%m-%d', '%h': '%b', '%r': '%I:%M:%S %p', '%R': '%H:%M', '%T': '%H:%M:%S', '%x': '%m/%d/%y', '%X': '%H:%M:%S', '%Ec': '%c', '%EC': '%C', '%Ex': '%m/%d/%y', '%EX': '%H:%M:%S', '%Ey': '%y', '%EY': '%Y', '%Od': '%d', '%Oe': '%e', '%OH': '%H', '%OI': '%I', '%Om': '%m', '%OM': '%M', '%OS': '%S', '%Ou': '%u', '%OU': '%U', '%OV': '%V', '%Ow': '%w', '%OW': '%W', '%Oy': '%y' }; for (var rule in EXPANSION_RULES_1) { pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]) } const WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; const MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']; function leadingSomething (value, digits, character) { let str = typeof value === 'number' ? value.toString() : value || ''; while (str.length < digits) { str = character[0] + str } return str } function leadingNulls (value, digits) { return leadingSomething(value, digits, '0') } function compareByDay (date1, date2) { function sgn (value) { return value < 0 ? -1 : value > 0 ? 1 : 0 } let compare; if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) { if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) { compare = sgn(date1.getDate() - date2.getDate()) } } return compare } function getFirstWeekStartDate (janFourth) { switch (janFourth.getDay()) { case 0:return new Date(janFourth.getFullYear() - 1, 11, 29); case 1:return janFourth; case 2:return new Date(janFourth.getFullYear(), 0, 3); case 3:return new Date(janFourth.getFullYear(), 0, 2); case 4:return new Date(janFourth.getFullYear(), 0, 1); case 5:return new Date(janFourth.getFullYear() - 1, 11, 31); case 6:return new Date(janFourth.getFullYear() - 1, 11, 30) } } function getWeekBasedYear (date) { const thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday); const janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4); const janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4); const firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear); const firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear); if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) { if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) { return thisDate.getFullYear() + 1 } else { return thisDate.getFullYear() } } else { return thisDate.getFullYear() - 1 } } const EXPANSION_RULES_2 = { '%a': function (date) { return WEEKDAYS[date.tm_wday].substring(0, 3) }, '%A': function (date) { return WEEKDAYS[date.tm_wday] }, '%b': function (date) { return MONTHS[date.tm_mon].substring(0, 3) }, '%B': function (date) { return MONTHS[date.tm_mon] }, '%C': function (date) { const year = date.tm_year + 1900; return leadingNulls(year / 100 | 0, 2) }, '%d': function (date) { return leadingNulls(date.tm_mday, 2) }, '%e': function (date) { return leadingSomething(date.tm_mday, 2, ' ') }, '%g': function (date) { return getWeekBasedYear(date).toString().substring(2) }, '%G': function (date) { return getWeekBasedYear(date) }, '%H': function (date) { return leadingNulls(date.tm_hour, 2) }, '%I': function (date) { let twelveHour = date.tm_hour; if (twelveHour == 0)twelveHour = 12; else if (twelveHour > 12)twelveHour -= 12; return leadingNulls(twelveHour, 2) }, '%j': function (date) { return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3) }, '%m': function (date) { return leadingNulls(date.tm_mon + 1, 2) }, '%M': function (date) { return leadingNulls(date.tm_min, 2) }, '%n': function () { return '\n' }, '%p': function (date) { if (date.tm_hour >= 0 && date.tm_hour < 12) { return 'AM' } else { return 'PM' } }, '%S': function (date) { return leadingNulls(date.tm_sec, 2) }, '%t': function () { return '\t' }, '%u': function (date) { return date.tm_wday || 7 }, '%U': function (date) { const days = date.tm_yday + 7 - date.tm_wday; return leadingNulls(Math.floor(days / 7), 2) }, '%V': function (date) { let val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7); if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) { val++ } if (!val) { val = 52; const dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7; if (dec31 == 4 || dec31 == 5 && __isLeapYear(date.tm_year % 400 - 1)) { val++ } } else if (val == 53) { const jan1 = (date.tm_wday + 371 - date.tm_yday) % 7; if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year)))val = 1 } return leadingNulls(val, 2) }, '%w': function (date) { return date.tm_wday }, '%W': function (date) { const days = date.tm_yday + 7 - (date.tm_wday + 6) % 7; return leadingNulls(Math.floor(days / 7), 2) }, '%y': function (date) { return (date.tm_year + 1900).toString().substring(2) }, '%Y': function (date) { return date.tm_year + 1900 }, '%z': function (date) { let off = date.tm_gmtoff; const ahead = off >= 0; off = Math.abs(off) / 60; off = off / 60 * 100 + off % 60; return (ahead ? '+' : '-') + String('0000' + off).slice(-4) }, '%Z': function (date) { return date.tm_zone }, '%%': function () { return '%' } }; pattern = pattern.replace(/%%/g, '\0\0'); for (var rule in EXPANSION_RULES_2) { if (pattern.includes(rule)) { pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date)) } }pattern = pattern.replace(/\0\0/g, '%'); const bytes = intArrayFromString(pattern, false); if (bytes.length > maxsize) { return 0 }writeArrayToMemory(bytes, s); return bytes.length - 1 } function _system (command) { if (ENVIRONMENT_IS_NODE) { if (!command) return 1; const cmdstr = UTF8ToString(command); if (!cmdstr.length) return 0; const cp = require('child_process'); const ret = cp.spawnSync(cmdstr, [], { shell: true, stdio: 'inherit' }); const _W_EXITCODE = (ret, sig) => ret << 8 | sig; if (ret.status === null) { const signalToNumber = sig => { switch (sig) { case 'SIGHUP':return 1; case 'SIGINT':return 2; case 'SIGQUIT':return 3; case 'SIGFPE':return 8; case 'SIGKILL':return 9; case 'SIGALRM':return 14; case 'SIGTERM':return 15 } return 2 }; return _W_EXITCODE(0, signalToNumber(ret.signal)) } return _W_EXITCODE(ret.status, 0) } if (!command) return 0; setErrNo(52); return -1 } function intArrayFromString (stringy, dontAddNull, length) { const len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; const u8array = new Array(len); const numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull)u8array.length = numBytesWritten; return u8array } var asmLibraryArg = { w: ___syscall_dup3, d: ___syscall_fcntl64, z: ___syscall_ioctl, r: ___syscall_lstat64, g: ___syscall_openat, s: ___syscall_renameat, t: ___syscall_rmdir, e: ___syscall_unlinkat, a: __emscripten_date_now, A: __emscripten_get_now_is_monotonic, p: __emscripten_throw_longjmp, B: __gmtime_js, C: __localtime_js, i: __mktime_js, j: __tzset_js, D: _abort, k: _emscripten_memcpy_big, q: _emscripten_resize_heap, u: _environ_get, v: _environ_sizes_get, l: _exit, c: _fd_close, y: _fd_read, o: _fd_seek, f: _fd_write, h: _getTempRet0, x: invoke_vii, b: _setTempRet0, n: _strftime, m: _system }; const asm = createWasm(); var ___wasm_call_ctors = Module.___wasm_call_ctors = function () { return (___wasm_call_ctors = Module.___wasm_call_ctors = Module.asm.F).apply(null, arguments) }; var _handle = Module._handle = function () { return (_handle = Module._handle = Module.asm.G).apply(null, arguments) }; var _main = Module._main = function () { return (_main = Module._main = Module.asm.H).apply(null, arguments) }; var _malloc = Module._malloc = function () { return (_malloc = Module._malloc = Module.asm.J).apply(null, arguments) }; var ___errno_location = Module.___errno_location = function () { return (___errno_location = Module.___errno_location = Module.asm.K).apply(null, arguments) }; var _setThrew = Module._setThrew = function () { return (_setThrew = Module._setThrew = Module.asm.L).apply(null, arguments) }; var stackSave = Module.stackSave = function () { return (stackSave = Module.stackSave = Module.asm.M).apply(null, arguments) }; var stackRestore = Module.stackRestore = function () { return (stackRestore = Module.stackRestore = Module.asm.N).apply(null, arguments) }; var stackAlloc = Module.stackAlloc = function () { return (stackAlloc = Module.stackAlloc = Module.asm.O).apply(null, arguments) }; function invoke_vii (index, a1, a2) { const sp = stackSave(); try { getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } let MAGIC = 0; Math.random = () => { MAGIC = Math.pow(MAGIC + 1.8912, 3) % 1; return MAGIC }; let TIME = 1e4; Date.now = () => TIME++; if (typeof performance === 'object')performance.now = Date.now; if (ENVIRONMENT_IS_NODE)process.hrtime = Date.now; if (!Module)Module = {}; Module.thisProgram = 'thisProgram'; Module.cwrap = cwrap; let calledRun; function ExitStatus (status) { this.name = 'ExitStatus'; this.message = 'Program terminated with exit(' + status + ')'; this.status = status } let calledMain = false; dependenciesFulfilled = function runCaller () { if (!calledRun)run(); if (!calledRun)dependenciesFulfilled = runCaller }; function callMain (args) { const entryFunction = Module._main; const argc = 0; const argv = 0; try { const ret = entryFunction(argc, argv); exit(ret, true); return ret } catch (e) { return handleException(e) } finally { calledMain = true } } function run (args) { args = args || arguments_; if (runDependencies > 0) { return }preRun(); if (runDependencies > 0) { return } function doRun () { if (calledRun) return; calledRun = true; Module.calledRun = true; if (ABORT) return; initRuntime(); preMain(); readyPromiseResolve(Module); if (Module.onRuntimeInitialized)Module.onRuntimeInitialized(); if (shouldRunNow)callMain(args); postRun() } if (Module.setStatus) { Module.setStatus('Running...'); setTimeout(function () { setTimeout(function () { Module.setStatus('') }, 1); doRun() }, 1) } else { doRun() } }Module.run = run; function exit (status, implicit) { EXITSTATUS = status; procExit(status) } function procExit (code) { EXITSTATUS = code; if (!keepRuntimeAlive()) { if (Module.onExit)Module.onExit(code); ABORT = true }quit_(code, new ExitStatus(code)) } if (Module.preInit) { if (typeof Module.preInit === 'function')Module.preInit = [Module.preInit]; while (Module.preInit.length > 0) { Module.preInit.pop()() } } var shouldRunNow = true; if (Module.noInitialRun)shouldRunNow = false; run()

      return Module.ready
    }
  )
})()
/* eslint-enable */

/**
 * @typedef Tag
 * @property {string} name
 * @property {string} value
 */

/**
 * @typedef Message
 * @property {string} [Signature]
 * @property {string} Owner
 * @property {string} Target
 * @property {string} [Anchor]
 * @property {Tag[]} Tags
 * @property {DataItem} [Data]
 * @property {string} From
 * @property {string} [Forwarded-By]
 * @property {string} [Epoch]
 * @property {string} [Nonce]
 * @property {string} Block-Height
 * @property {string} Timestamp
 * @property {string} [Hash-Chain]
 * @property {boolean} Cron
 */

/**
 * @typedef Environment
 * @property {{id: string, owner: string, tags: Tag[]}} process
 */

/**
 * @typedef HandleResponse
 * @property {ArrayBuffer} Memory
 * @property {DataItem} Output
 * @property {Message[]} Messages
 * @property {Message[]} Spawns
 */

/**
 * @callback handleFunction
 * @param {ArrayBuffer | NULL} buffer
 * @param {Message} msg
 * @param {Environment} env
 * @returns {HandleResponse}
 */

/**
 * @param {ArrayBuffer} binary
 * @returns {Promise<handleFunction>}
 */
module.exports = async function (binary, limit) {
  const instance = await Module(binary, limit)

  /**
   * Since the module can be invoked multiple times, there isn't really
   * a good place to cleanup these listeners (since emscripten doesn't do it),
   * other than immediately.
   *
   * I don't really see where they are used, since CU implementations MUST
   * catch reject Promises from the WASM module, as part of evaluation.
   *
   * TODO: maybe a better way to do this
   *
   * So we immediately remove any listeners added by Module,
   * in order to prevent memory leaks
   */
  instance.cleanupListeners()
  const doHandle = instance.cwrap('handle', 'string', ['string', 'string'])

  return (buffer, msg, env) => {
    const originalRandom = Math.random
    const originalPerformance = performance.now
    const OriginalDate = Date
    const originalNow = Date.now
    const originalLog = console.log
    try {
      /** start mock Math.random */
      Math.random = function () { return 0.5 }
      /** end mock Math.random */

      /** start mock Date */
      performance.now = function () { return 0 }
      // eslint-disable-next-line no-global-assign
      Date = function () {
        if (arguments.length === 0) {
          // Return a specific date and time (e.g., January 1, 2022)
          return new OriginalDate('2022-01-01T00:00:00.000Z')
        } else {
          // If arguments are provided, use the original Date constructor
          return new OriginalDate(...arguments)
        }
      }
      Date.now = function () { return new OriginalDate('2022-01-01T00:00:00.000Z') }
      /** end mock Date */

      /** start mock console.log */
      console.log = function () { return null }
      /** end mock console.log */

      if (buffer) instance.HEAPU8.set(buffer)
      /**
       * Make sure to refill the gas tank for each invocation
       */
      instance.gas.refill()
      const { ok, response } = JSON.parse(doHandle(JSON.stringify(msg), JSON.stringify(env)))
      if (!ok) throw response

      /** unmock functions */
      // eslint-disable-next-line no-global-assign
      Date = OriginalDate
      Math.random = originalRandom
      performance.now = originalPerformance
      console.log = originalLog
      /** end unmock */

      return {
        Memory: instance.HEAPU8.slice(),
        Error: response.Error,
        Output: response.Output,
        Messages: response.Messages,
        Spawns: response.Spawns,
        GasUsed: instance.gas.used
      }
    } finally {
      // eslint-disable-next-line no-global-assign
      Date = OriginalDate
      Date.now = originalNow
      Math.random = originalRandom
      performance.now = originalPerformance
      console.log = originalLog
    }
  }
}
