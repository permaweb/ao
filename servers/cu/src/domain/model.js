import { z } from 'zod'

export const domainConfigSchema = z.object({
  GATEWAY_URL: z.string().url('GATEWAY_URL must be a a valid URL'),
  DB_MODE: z.enum(['remote', 'embedded']),
  DB_URL: z.string().min(1, 'DB_URL must be set to the database connection string'),
  DB_MAX_LISTENERS: z.number().int('DB_MAX_LISTENERS must be an integer'),
  WALLET: z.string().min(1, 'WALLET must be a Wallet JWK Inteface')
})

export const streamSchema = z.any().refine(stream => {
  return stream !== null &&
    typeof stream === 'object' &&
    typeof stream.pipe === 'function'
}, { message: 'Value must implement the iteration protocol' })

export const rawTagSchema = z.object({
  name: z.string(),
  value: z.string()
})

export const rawBlockSchema = z.object({
  height: z.coerce.number(),
  timestamp: z.coerce.number()
})

export const processSchema = z.object({
  id: z.string().min(1),
  /**
   * nullish for backwards compatibility
   */
  signature: z.string().nullish(),
  data: z.any().nullish(),
  anchor: z.string().nullish(),
  owner: z.string().min(1),
  tags: z.array(rawTagSchema),
  block: rawBlockSchema
})

export const messageSchema = z.object({
  /**
   * Whether or not this message's evaluation should be saved.
   *
   * This is currently used ONLY for the initial message on a process
   * cold start
   */
  noSave: z.boolean().default(false),
  /**
   * The deep hash for the message. Only calculated by the CU
   * for messages with a Forwarded-For tag.
   *
   * This is value is ultimately persisted, so that it can be queried
   * to detect duplicate messages and remove them from the eval stream
   */
  deepHash: z.string().nullish(),
  /**
   * If the message was generated as the result of a Cron-Interval,
   * The unique identifier of the cron that produced this message
   */
  cron: z.string().nullish(),
  /**
   * Used as part of guaranteeing ordering for evaluations in the CU.
   *
   * For scheduled messages, this is simply set to the nonce.
   * For cron messages, this is set to the most recent scheduled messages nonce,
   * or a small unicode code.
   *
   * The important bit is that this value is lexicographically sortable
   *
   * This way, all messages, scheduled and cron, remain orderable.
   */
  ordinate: z.coerce.string(),
  /**
   * A canonical name that can used for logging purposes
   */
  name: z.string(),
  message: z.object({
    /**
     * The tx id of the message ie. the data item id
     *
     * cron messages do not have an id, so this is optional
     */
    Id: z.string().nullish(),
    /**
     * cron messages are generated by a CU, and not signed, and so not have a signature,
     * so this is optional
     */
    Signature: z.string().nullish(),
    Data: z.any().nullish(),
    Owner: z.string().min(1),
    Target: z.string().min(1),
    Anchor: z.string().nullish(),
    From: z.string().min(1),
    'Forwarded-By': z.string().nullish(),
    Tags: z.array(rawTagSchema),
    /**
     * cron messages do not have a nonce or epoch
     * since they are generated "between" nonces received
     * from a SU
     */
    Epoch: z.number().nullish(),
    Nonce: z.number().nullish(),
    Timestamp: z.coerce.number(),
    'Block-Height': z.coerce.number(),
    /**
     * cron messages are not included in the hash chain, and so do not have one,
     * so this is optional
     */
    'Hash-Chain': z.string().nullish(),
    /**
     * Whether the message is a cron generated message or not
     */
    Cron: z.boolean(),
    'Read-Only': z.boolean().default(false)
  }),
  AoGlobal: z.object({
    Process: z.object({
      Id: z.string(),
      Owner: z.string(),
      Tags: z.array(rawTagSchema)
    })
  }).passthrough() // TODO: remove once AoGlobal is more defined
}).passthrough()

export const scheduleSchema = z.object({
  name: z.string(),
  cron: z.string().nullish(),
  blocks: z.number().nullish(),
  message: z.any()
})

export const evaluationSchema = z.object({
  /**
   * the id of the process that the message was performed upon
   */
  processId: z.string().min(1),
  /**
   * Cron messages do not have a messageId
   * and so can be undefined
   */
  messageId: z.string().min(1).nullish(),
  timestamp: z.coerce.number(),
  ordinate: z.coerce.string(),
  blockHeight: z.coerce.number(),
  /**
   * Scheduled messages do not have a cron,
   * and so can be undefined
   */
  cron: z.string().nullish(),
  /**
   * The date when this record was created, effectively
   * when this record was evaluated
   *
   * not to be confused with when the transaction was placed on chain
   */
  evaluatedAt: z.preprocess(
    (
      arg
    ) => (typeof arg === 'string' || arg instanceof Date ? new Date(arg) : arg),
    z.date()
  ),
  /**
   * ao processes return { Memory, Message, Spawns, Output, Error } }
   *
   * This is the output of process, after the action was applied
   */
  output: z.object({
    Memory: z.any().nullish(),
    Messages: z.array(z.any()).nullish(),
    Spawns: z.array(z.any()).nullish(),
    Output: z.any().nullish(),
    Error: z.any().nullish()
  })
})
