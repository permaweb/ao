"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceImpl = void 0;
/* eslint-disable */
const warp_isomorphic_1 = require("warp-isomorphic");
const warp_contracts_1 = require("warp-contracts");
const arbundles_1 = require("arbundles");
const utils_1 = require("../../deploy/utils");
const WasmHandler_1 = require("../../deploy/wasm/WasmHandler");
class SourceImpl {
    constructor(warp) {
        this.warp = warp;
        this.logger = warp_contracts_1.LoggerFactory.INST.create('Source');
    }
    async createSource(sourceData, wallet, disableBundling = false) {
        this.logger.debug('Creating new contract source');
        const { src, wasmSrcCodeDir, wasmGlueCode } = sourceData;
        if (this.warp.environment == 'local') {
            disableBundling = true;
        }
        const effectiveUseBundler = disableBundling == undefined ? this.warp.definitionLoader.type() == 'warp' : !disableBundling;
        if (!effectiveUseBundler && (0, utils_1.isSigner)(wallet)) {
            throw new Error('Only ArWallet | CustomSignature wallet type are allowed when bundling is disabled.');
        }
        if (effectiveUseBundler && !(0, utils_1.isSigner)(wallet)) {
            throw new Error('Only Signer wallet type is allowed when bundling is enabled.');
        }
        const contractType = src instanceof warp_isomorphic_1.Buffer ? 'wasm' : 'js';
        if (contractType == 'js' && !(0, warp_contracts_1.checkJsSrc)(sourceData.src, this.logger)) {
            throw new Error('JS contract source does not contain properly exported "handle" function');
        }
        let wasmData = null;
        let srcWasmTags = [];
        if (contractType == 'wasm') {
            const wasmHandler = new WasmHandler_1.WasmHandler(src, wasmSrcCodeDir, wasmGlueCode);
            ({ wasmData, srcWasmTags } = await wasmHandler.createWasmSrc());
        }
        const allData = contractType == 'wasm' ? wasmData : src;
        const srcTags = [
            new warp_contracts_1.Tag(warp_contracts_1.SMART_WEAVE_TAGS.APP_NAME, 'SmartWeaveContractSource'),
            new warp_contracts_1.Tag(warp_contracts_1.SMART_WEAVE_TAGS.APP_VERSION, '0.3.0'),
            new warp_contracts_1.Tag(warp_contracts_1.SMART_WEAVE_TAGS.SDK, 'Warp'),
            new warp_contracts_1.Tag(warp_contracts_1.WARP_TAGS.NONCE, Date.now().toString()),
            new warp_contracts_1.Tag(warp_contracts_1.SMART_WEAVE_TAGS.CONTENT_TYPE, contractType == 'js' ? 'application/javascript' : 'application/wasm')
        ];
        if (disableBundling) {
            return this.createSourceArweave(wallet, allData, srcTags, srcWasmTags, contractType);
        }
        else {
            return await this.createSourceBundlr(wallet, srcTags, srcWasmTags, contractType, allData);
        }
    }
    async saveSource(src, disableBundling) {
        this.logger.debug('Saving contract source', src.id);
        if (this.warp.environment == 'local') {
            disableBundling = true;
        }
        const effectiveUseBundler = disableBundling == undefined ? this.warp.definitionLoader.type() == 'warp' : !disableBundling;
        if ((0, utils_1.isDataItem)(src) && !effectiveUseBundler) {
            throw new Error(`Unable to save data item when bundling is disabled.`);
        }
        if (!(0, utils_1.isDataItem)(src)) {
            const tagsParser = new warp_contracts_1.TagsParser();
            const signatureTag = tagsParser.getTag(src, warp_contracts_1.WARP_TAGS.SIGNATURE_TYPE);
            if (signatureTag && signatureTag != 'arweave' && !effectiveUseBundler) {
                throw new Error(`Unable to save source with signature type: ${signatureTag} when bundling is disabled.`);
            }
        }
        let responseOk;
        let response;
        if (effectiveUseBundler) {
            const result = await this.postSource(src.getRaw());
            this.logger.debug(result);
            responseOk = true;
        }
        else {
            response = await this.warp.arweave.transactions.post(src);
            responseOk = response.status === 200 || response.status === 208;
        }
        if (responseOk) {
            return src.id;
        }
        else {
            throw new Error(`Unable to write Contract Source. Arweave responded with status ${response.status}: ${response.statusText}`);
        }
    }
    async postSource(srcDataItem) {
        return await (0, warp_contracts_1.getJsonResponse)(fetch(`${this.warp.gwUrl()}/gateway/v2/sources/deploy`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/octet-stream',
                Accept: 'application/json'
            },
            body: srcDataItem
        }));
    }
    async createSourceArweave(wallet, data, srcTags, srcWasmTags, contractType) {
        this.signature = new warp_contracts_1.Signature(this.warp, wallet);
        if (this.signature.type !== 'arweave') {
            throw new Error(`Unable to use signing function of type: ${this.signature.type}.`);
        }
        const signer = this.signature.signer;
        const srcTx = await this.warp.arweave.createTransaction({ data });
        srcTags.forEach((t) => srcTx.addTag(t.name, t.value));
        if (contractType == 'wasm') {
            srcWasmTags.forEach((t) => srcTx.addTag(t.name, t.value));
        }
        if (this.warp.environment === 'testnet') {
            srcTx.addTag(warp_contracts_1.WARP_TAGS.WARP_TESTNET, '1.0.0');
        }
        await signer(srcTx);
        this.logger.debug('Posting transaction with source');
        return srcTx;
    }
    async createSourceBundlr(wallet, srcTags, srcWasmTags, contractType, data) {
        const srcDataItemTags = [...srcTags];
        if (contractType == 'wasm') {
            srcWasmTags.forEach((t) => srcDataItemTags.push(new warp_contracts_1.Tag(t.name, t.value)));
        }
        if (this.warp.environment === 'testnet') {
            srcDataItemTags.push(new warp_contracts_1.Tag(warp_contracts_1.WARP_TAGS.WARP_TESTNET, '1.0.0'));
        }
        let srcDataItem;
        if ((0, warp_contracts_1.isBrowser)() && wallet.signer && wallet.signer.signDataItem) {
            srcDataItem = await wallet.signDataItem(data, srcDataItemTags);
        }
        else {
            srcDataItem = (0, arbundles_1.createData)(data, wallet, { tags: srcDataItemTags });
            await srcDataItem.sign(wallet);
        }
        this.logger.debug('Posting transaction with source');
        return srcDataItem;
    }
}
exports.SourceImpl = SourceImpl;
//# sourceMappingURL=SourceImpl.js.map